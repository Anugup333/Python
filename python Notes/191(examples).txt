#Program for Dead Lock Occurence
#DeadLockFunEx1.py
import threading,time
def table(n):
	if(n<=0):
		print("{}-->{} Invalid Input".format(threading.current_thread().name,n))
	else:
		for i in range(1,11):
			print("\t{}--->{} x {} = {}".format(threading.current_thread().name,n,i,n*i))
			time.sleep(1)
		print("---------------------------------------------------------")

#Main Program
t1=threading.Thread(target=table,args=(17,))
t1.name="RS"
t2=threading.Thread(target=table,args=(7,))
t2.name="TR"
t3=threading.Thread(target=table,args=(-19,))
t3.name="JH"
t4=threading.Thread(target=table,args=(18,))
t4.name="DR"
#dispatch the sub threads
t1.start()
t2.start()
t3.start()
t4.start()

#Program for Dead Lock Occurence
#DeadLockOopEx1.py
import threading,time
class MulTable:
	def table(self,n):
		if(n<=0):
			print("{}-->{} Invalid Input".format(threading.current_thread().name,n))
		else:
			for i in range(1,11):
				print("\t{}--->{} x {} = {}".format(threading.current_thread().name,n,i,n*i))
				time.sleep(1)
			print("---------------------------------------------------------")

#Main Program
t1=threading.Thread(target=MulTable().table,args=(17,))
t1.name="RS"
t2=threading.Thread(target=MulTable().table,args=(7,))
t2.name="TR"
t3=threading.Thread(target=MulTable().table,args=(-19,))
t3.name="JH"
t4=threading.Thread(target=MulTable().table,args=(18,))
t4.name="DR"
#dispatch the sub threads
t1.start()
t2.start()
t3.start()
t4.start()


#Program for Dead Lock Elimination
#DeadLockEliminateFunEx1.py
import threading,time
def table(n):
	#Get the Lock--Step-2
	L.acquire()
	if(n<=0):
		print("{}-->{} Invalid Input".format(threading.current_thread().name,n))
	else:
		for i in range(1,11):
			print("\t{}--->{} x {} = {}".format(threading.current_thread().name,n,i,n*i))
			time.sleep(0.01)
	print("---------------------------------------------------------")
	#Release the Lock-Step-3
	L.release() 
#Main Program
#Create an Object of Lock Class of threading module
L=threading.Lock() # Step-1
#Create Multiple Threads with Same target Functions 
t1=threading.Thread(target=table,args=(17,))
t1.name="RS"
t2=threading.Thread(target=table,args=(7,))
t2.name="TR"
t3=threading.Thread(target=table,args=(-19,))
t3.name="JH"
t4=threading.Thread(target=table,args=(18,))
t4.name="DR"
#dispatch the sub threads
t1.start()
t2.start()
t3.start()
t4.start()

#Program for Dead Lock Elimination
#DeadLockEliminateOopEx1.py
import threading,time
class MulTable:
	def table(self,n):
		#Get the Lock--Step-2
		L.acquire()
		if(n<=0):
			print("{}-->{} Invalid Input".format(threading.current_thread().name,n))
		else:
			for i in range(1,11):
				print("\t{}--->{} x {} = {}".format(threading.current_thread().name,n,i,n*i))
				time.sleep(0.00001)
		print("---------------------------------------------------------")
		#Release the Lock-Step-3
		L.release() 
#Main Program
#Create an Object of Lock Class of threading module
L=threading.Lock() # Step-1
#Create Multiple Threads with Same target Functions 
t1=threading.Thread(target=MulTable().table,args=(17,))
t1.name="RS"
t2=threading.Thread(target=MulTable().table,args=(7,))
t2.name="TR"
t3=threading.Thread(target=MulTable().table,args=(19,))
t3.name="JH"
t4=threading.Thread(target=MulTable().table,args=(18,))
t4.name="DR"
#dispatch the sub threads
t1.start()
t2.start()
t3.start()
t4.start()

#Program for Dead Lock Elimination
#DeadLockEliminateOopEx2.py
import threading,time
class MulTable:
	#Create an Object of Lock Class of threading module
	L=threading.Lock() # Step-1--Here L is called Class Level Data Member
	def table(self,n):
		#Get the Lock--Step-2
		MulTable.L.acquire()
		if(n<=0):
			print("{}-->{} Invalid Input".format(threading.current_thread().name,n))
		else:
			for i in range(1,11):
				print("\t{}--->{} x {} = {}".format(threading.current_thread().name,n,i,n*i))
				time.sleep(0.00001)
		print("---------------------------------------------------------")
		#Release the Lock-Step-3
		MulTable.L.release() 
#Main Program

#Create Multiple Threads with Same target Functions 
t1=threading.Thread(target=MulTable().table,args=(17,))
t1.name="RS"
t2=threading.Thread(target=MulTable().table,args=(7,))
t2.name="TR"
t3=threading.Thread(target=MulTable().table,args=(19,))
t3.name="JH"
t4=threading.Thread(target=MulTable().table,args=(18,))
t4.name="DR"
#dispatch the sub threads
t1.start()
t2.start()
t3.start()
t4.start()

#Program for Dead Lock Elimination
#DeadLockEliminateOopEx3.py
import threading,time
class MulTable:
	#Create an Object of Lock Class of threading module
	L=threading.Lock() # Step-1--Here L is called Class Level Data Member
	def __init__(self,n):
		self.n=n
	def table(self):
		#Get the Lock--Step-2
		MulTable.L.acquire()
		if(self.n<=0):
			print("{}-->{} Invalid Input".format(threading.current_thread().name,self.n))
		else:
			for i in range(1,11):
				print("\t{}--->{} x {} = {}".format(threading.current_thread().name,self.n,i,self.n*i))
				time.sleep(0.01)
		print("---------------------------------------------------------")
		#Release the Lock-Step-3
		MulTable.L.release() 
#Main Program

#Create Multiple Threads with Same target Functions 
t1=threading.Thread(target=MulTable(-17).table)
t1.name="RS"
t2=threading.Thread(target=MulTable(7).table)
t2.name="TR"
t3=threading.Thread(target=MulTable(-19).table)
t3.name="JH"
t4=threading.Thread(target=MulTable(18).table)
t4.name="DR"
#dispatch the sub threads
t1.start()
t2.start()
t3.start()
t4.start()

#Program for generatng Odd and Even Number by Multiple Threads
#OddEvenNumbersFunEx1.py
import threading,time
def  odd(n):
	if(n<=0):
		print("{}-->{} Invalid Input".format(threading.current_thread().name,n))
	else:
		for i in range(1,n+1,2):
			print("{}--->Odd Number:{}".format(threading.current_thread().name,i))
			time.sleep(0.5)
		print("-----------------------------------------------------------")
def even(n):
		if(n<=0):
			print("{}-->{} Invalid Input".format(threading.current_thread().name,n))
		else:
			for i in range(2,n+1,2):
				print("{}--->Even Number:{}".format(threading.current_thread().name,i))
				time.sleep(0.5)
			print("-----------------------------------------------------------")

#Main Program
#Create 2 Threads 
t1=threading.Thread(target=odd,args=(int(input("Enter How Many Odd Numbers u want to generate:")),))
t2=threading.Thread(target=even,args=(int(input("Enter How Many Even Numbers u want to generate:")),))
#dispatch the sub threads
t1.start()
t2.start()

#Program for Dead Lock Elimination
#TrainReservationOopEx1.py
import threading,time
class Train:
	lockobj=threading.Lock()
	totseats=12
	def __init__(self,seats):
		self.seats=seats
	def  reservation(self):
		Train.lockobj.acquire()
		if(self.seats>Train.totseats):
			print("\t Dear Passenger {},  {} Seats Not Available--Try Next".format(threading.current_thread().name,self.seats))
			time.sleep(3)
		else:
			Train.totseats=Train.totseats-self.seats
			print("\t Dear Passenger {},  {} Seats Reserved--hpy jrny ".format(threading.current_thread().name,self.seats))
			time.sleep(3)
			print("\tNow Available Seats:{}".format(Train.totseats))
			time.sleep(3)
		Train.lockobj.release()

#Main Program
t1=threading.Thread(target=Train(15).reservation)
t1.name="Sasi"
t2=threading.Thread(target=Train(2).reservation)
t2.name="Sai"
t3=threading.Thread(target=Train(4).reservation)
t3.name="Chran"
t4=threading.Thread(target=Train(8).reservation)
t4.name="Prajwal"
t5=threading.Thread(target=Train(4).reservation)
t5.name="Moula"
t6=threading.Thread(target=Train(2).reservation)
t6.name="Meghna"
t7=threading.Thread(target=Train(1).reservation)
t7.name="pavan"
#Dispatch the Threads
t1.start()
t2.start()
t3.start()
t4.start()
t5.start()
t6.start()
t7.start()

#Program for Dead Lock Elimination
#BankTransactionOopEx1.py
import threading,time
class Bank:
	lockobj=threading.Lock()
	VMACC=2500
	def __init__(self,chamt):
		self.chamt=chamt
	def  clearence(self):
		Bank.lockobj.acquire()
		if(self.chamt>Bank.VMACC):
			print("\t Dear Customer {}, INR {} Check Bounced--Contact Source".format(threading.current_thread().name,self.chamt))
			time.sleep(3)
		else:
			Bank.VMACC=Bank.VMACC-self.chamt
			print("\t Dear Customer {}, INR {} Check Cleared".format(threading.current_thread().name,self.chamt))
			time.sleep(3)
			print("\tNow Available Balance at Source:{}".format(Bank.VMACC))
			time.sleep(3)
		Bank.lockobj.release()


#Main Program
t1=threading.Thread(target=Bank(5000).clearence)
t1.name="Mansi"
t2=threading.Thread(target=Bank(2000).clearence)
t2.name="Uma"
t3=threading.Thread(target=Bank(4000).clearence)
t3.name="Namtritha"
t4=threading.Thread(target=Bank(2500).clearence)
t4.name="Bargavi"
t5=threading.Thread(target=Bank(10000).clearence)
t5.name="Pallavi"
t6=threading.Thread(target=Bank(500).clearence)
t6.name="Kvr"
t7=threading.Thread(target=Bank(1500).clearence)
t7.name="Srinu"
#Dispatch the Threads
t1.start()
t2.start()
t3.start()
t4.start()
t5.start()
t6.start()
t7.start()